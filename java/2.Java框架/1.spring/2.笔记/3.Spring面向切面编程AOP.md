Spring入门（三）：面向切面编程AOP
<!-- TOC -->

- [1. AOP的相关概念](#1-aop的相关概念)
    - [1.1. 什么是AOP](#11-什么是aop)
    - [1.2. AOP 的作用及优势](#12-aop-的作用及优势)
    - [1.3. AOP具体应用](#13-aop具体应用)
        - [1.3.1. 案例](#131-案例)
        - [1.3.2. 解决方案](#132-解决方案)
        - [1.3.3. 新的问题](#133-新的问题)
        - [1.3.4. 动态代理](#134-动态代理)
- [2. 动态代理](#2-动态代理)
    - [2.1. 动态代理常用的有两种方式](#21-动态代理常用的有两种方式)
    - [2.2. 使用JDK官方的Proxy类创建代理对象](#22-使用jdk官方的proxy类创建代理对象)
    - [2.3. 使用CGLib的Enhancer类创建代理对象](#23-使用cglib的enhancer类创建代理对象)
    - [第一章节的解决方案](#第一章节的解决方案)
- [Spring中的AOP](#spring中的aop)
    - [Spring中AOP的细节](#spring中aop的细节)
        - [SOP术语](#sop术语)
        - [抽取公共代码制作成通知](#抽取公共代码制作成通知)
- [3. 参考文档](#3-参考文档)

<!-- /TOC -->
# 1. AOP的相关概念
## 1.1. 什么是AOP
AOP ：Aspect Oriented Programming -- 面向切面编程。  
简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。
## 1.2. AOP 的作用及优势
* 作用：  
&emsp;&emsp;在程序运行期间，不修改源码对已有方法进行增强。
* 优势：  
    * 减少重复代码  
    * 提高开发效率  
    * 维护方便  

* AOP的实现方式
使用动态代理技术。
## 1.3. AOP具体应用
<details>
  <summary>IAccountService</summary>
  
  ```java
package com.itheima.service;

import com.itheima.domain.Account;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * @author xiaolong_wu
 * @date 2019年09月24日
 * @function 账户的业务层接口
 **/
public interface IAccountService {

    /**
     * 查询所有
     * @return
     */
    List<Account> findAllAccount();

    /**
     * 查询一个
     * @return
     */
    Account findAccountById(Integer accountId);

    /**
     * 保存
     * @param account
     */
    void saveAccount(Account account);

    /**
     * 更新
     * @param account
     */
    void updateAccount(Account account);

    /**
     * 删除
     * @param acccountId
     */
    void deleteAccount(Integer acccountId);

    /**
     * 转账
     * @param sourceName        转出账户名称
     * @param targetName        转入账户名称
     * @param money             转账金额
     */
    void transfer(String sourceName, String targetName, Float money);




}

  ```
</details>

* 【存在的问题】
事务被自动控制了。换言之，我们使用了connection对象的setAutoCommit(true) 此方式控制事务，如果我们每次都执行一条sql语句，没有问题，但是如果业务方法一次要执行多条sql语句，这种方式就无法实现功能了。

### 1.3.1. 案例
在业务层加入一个方法。

<details>
  <summary>加入tranfer转账方法</summary>
  
  ```java
void transfer(String sourceName,String targetName,Float money);

    @Override
    public void transfer(String sourceName, String targetName, Float money) {
        System.out.println("transfer....");
        //2.1根据名称查询转出账户
        Account source = accountDao.findAccountByName(sourceName);
        //2.2根据名称查询转入账户
        Account target = accountDao.findAccountByName(targetName);
        //2.3转出账户减钱
        source.setMoney(source.getMoney() - money);
        //2.4转入账户加钱
        target.setMoney(target.getMoney() + money);
        //2.5更新转出账户
        accountDao.updateAccount(source);
//        int i= 1/0;  //模拟转账异常

        //2.6更新转入账户
        accountDao.updateAccount(target);

    }
  ```
</details>

* 【结果】
当我们执行时，由于执行有异常，转账失败。但是因为我们是每次执行持久层方法都是独立事务，导致无法实现事务控制（不符合事务的一致性）

### 1.3.2. 解决方案
<details>
  <summary>AccountServiceImpl_OLD.java</summary>
  
  ```java
package com.itheima.service.impl;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import com.itheima.service.IAccountService;
import com.itheima.utils.TransactionManager;

import java.util.List;

/**
 * 账户的业务层实现类
 *
 * 事务控制应该都是在业务层
 */
public class AccountServiceImpl_OLD implements IAccountService{

    private IAccountDao accountDao;
    private TransactionManager txManager;

    public void setTxManager(TransactionManager txManager) {
        this.txManager = txManager;
    }

    public void setAccountDao(IAccountDao accountDao) {
        this.accountDao = accountDao;
    }

    @Override
    public List<Account> findAllAccount() {
        try {
            //1.开启事务
            txManager.beginTransaction();
            //2.执行操作
            List<Account> accounts = accountDao.findAllAccount();
            //3.提交事务
            txManager.commit();
            //4.返回结果
            return accounts;
        }catch (Exception e){
            //5.回滚操作
            txManager.rollback();
            throw new RuntimeException(e);
        }finally {
            //6.释放连接
            txManager.release();
        }
    }

    @Override
    public Account findAccountById(Integer accountId) {
        try {
            //1.开启事务
            txManager.beginTransaction();
            //2.执行操作
            Account account = accountDao.findAccountById(accountId);
            //3.提交事务
            txManager.commit();
            //4.返回结果
            return account;
        }catch (Exception e){
            //5.回滚操作
            txManager.rollback();
            throw new RuntimeException(e);
        }finally {
            //6.释放连接
            txManager.release();
        }
    }

    @Override
    public void saveAccount(Account account) {
        try {
            //1.开启事务
            txManager.beginTransaction();
            //2.执行操作
            accountDao.saveAccount(account);
            //3.提交事务
            txManager.commit();
        }catch (Exception e){
            //4.回滚操作
            txManager.rollback();
        }finally {
            //5.释放连接
            txManager.release();
        }

    }

    @Override
    public void updateAccount(Account account) {
        try {
            //1.开启事务
            txManager.beginTransaction();
            //2.执行操作
            accountDao.updateAccount(account);
            //3.提交事务
            txManager.commit();
        }catch (Exception e){
            //4.回滚操作
            txManager.rollback();
        }finally {
            //5.释放连接
            txManager.release();
        }

    }

    @Override
    public void deleteAccount(Integer acccountId) {
        try {
            //1.开启事务
            txManager.beginTransaction();
            //2.执行操作
            accountDao.deleteAccount(acccountId);
            //3.提交事务
            txManager.commit();
        }catch (Exception e){
            //4.回滚操作
            txManager.rollback();
        }finally {
            //5.释放连接
            txManager.release();
        }

    }

    @Override
    public void transfer(String sourceName, String targetName, Float money) {
        try {
            //1.开启事务
            txManager.beginTransaction();
            //2.执行操作

            //2.1根据名称查询转出账户
            Account source = accountDao.findAccountByName(sourceName);
            //2.2根据名称查询转入账户
            Account target = accountDao.findAccountByName(targetName);
            //2.3转出账户减钱
            source.setMoney(source.getMoney()-money);
            //2.4转入账户加钱
            target.setMoney(target.getMoney()+money);
            //2.5更新转出账户
            accountDao.updateAccount(source);

            int i=1/0;

            //2.6更新转入账户
            accountDao.updateAccount(target);
            //3.提交事务
            txManager.commit();

        }catch (Exception e){
            //4.回滚操作
            txManager.rollback();
            e.printStackTrace();
        }finally {
            //5.释放连接
            txManager.release();
        }


    }
}

  ```
</details>

### 1.3.3. 新的问题
业务层方法变得臃肿了，里面充斥着很多重复代码。并且业务层方法和事务控制方法耦合了。

### 1.3.4. 动态代理
字节码随用随创建，随用随加载。  
 它与静态代理的区别也在于此。因为静态代理是字节码一上来就创建好，并完成加载。   
 装饰者模式就是静态代理的一种体现。


# 2. 动态代理

## 2.1. 动态代理常用的有两种方式
* 基于接口的动态代理
    * 提供者：JDK官方的Proxy类。  
    * 要求：**被代理类最少实现一个接口。**
* 基于子类的动态代理 
    * 提供者：第三方的CGLib，如果报asmxxxx异常，需要导入asm.jar。 
    * 要求：被代理类不能用final修饰的类（最终类）。

## 2.2. 使用JDK官方的Proxy类创建代理对象
案例：生产厂家得案例
<details>
  <summary>IProducer.java</summary>

```java
package com.itheima.proxy;

/**
 * 对生产厂家要求的接口
 */
public interface IProducer {

    /**
     * 销售
     * @param money
     */
    public void saleProduct(float money);

    /**
     * 售后
     * @param money
     */
    public void afterService(float money);
}
```
</details>

生产厂家
<details>
  <summary>Producer.java</summary>
  
```java
package com.itheima.proxy;

/**
 * @author xiaolong_wu
 * @date 2019年10月11日
 * @function
 **/
public class Producer implements IProducer{
    /**
     * 销售
     * @param money
     */
    public void saleProduct(float money) {
        System.out.println("销售产品，并拿到钱："+money);
    }

    /**
     * 售后
     * @param money
     */
    public void afterService(float money) {
        System.out.println("提供售后服务，并拿到钱："+money);
    }
}

```
</details>

客户端
<details>
  <summary>Client.java</summary>
  
```java
package com.itheima.proxy;


import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * @author xiaolong_wu
 * @date 2019年10月11日
 * @function
 **/
public class Client {
    public static void main(String[] args) {
        final Producer producer = new Producer();
        /**
         * 动态代理：
         *  特点：字节码随用随创建，随用随加载
         *  作用：不修改源码的基础上对方法增强
         *  分类：
         *      基于接口的动态代理
         *      基于子类的动态代理
         *  基于接口的动态代理：
         *      涉及的类：Proxy
         *      提供者：JDK官方
         *  如何创建代理对象：
         *      使用Proxy类中的newProxyInstance方法
         *  创建代理对象的要求：
         *      被代理类最少实现一个接口，如果没有则不能使用
         *  newProxyInstance方法的参数：
         *      ClassLoader：类加载器
         *          它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法。
         *      Class[]：字节码数组
         *          它是用于让代理对象和被代理对象有相同方法。固定写法。
         *      InvocationHandler：用于提供增强的代码
         *          它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。
         *          此接口的实现类都是谁用谁写。
         */
        IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),
                producer.getClass().getInterfaces(),
                new InvocationHandler() {
                    /**
                     * 作用：执行被代理对象的任何接口方法都会经过该方法
                     * 方法参数的含义
                     * @param proxy   代理对象的引用
                     * @param method  当前执行的方法
                     * @param args    当前执行方法所需的参数
                     * @return        和被代理对象方法有相同的返回值
                     * @throws Throwable
                     */
                     @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        //提供增强的代码
                        Object returnValue = null;

                        //1.获取方法执行的参数
                        Float money = (Float) args[0];

                        if("saleProduct".equals(method.getName())){
                            returnValue = method.invoke(producer,money*0.8f);
                        }
                        return returnValue;
                    }
                }
        );
        proxyProducer.saleProduct(10000f);

    }
}

```
</details>


## 2.3. 使用CGLib的Enhancer类创建代理对象
【备注】不需要实现接口
1. 生产者

<details>
  <summary>Producer.java</summary>
  
```java
package com.itheima.cglib;

/**
 * @author xiaolong_wu
 * @date 2019年10月11日
 * @function 生产者
 **/
public class Producer {

    /**
     * 销售
     * @param money
     */
    public void saleProduct(float money){
        System.out.println("销售产品，并拿到钱："+money);
    }

    /**
     * 售后
     * @param money
     */
    public void afterService(float money){
        System.out.println("提供售后服务，并拿到钱："+money);
    }
}

```
</details>

2. 客户端
<details>
  <summary>Client.java</summary>
  
```java
package com.itheima.cglib;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

/**
 * @author xiaolong_wu
 * @date 2019年10月11日
 * @function 基于Cglib的动态代理
 **/
public class Client {
    public static void main(String[] args) {
        final Producer producer = new Producer();

        /**
         * 动态代理：
         *  特点：字节码随用随创建，随用随加载
         *  作用：不修改源码的基础上对方法增强
         *  分类：
         *      基于接口的动态代理
         *      基于子类的动态代理
         *  基于子类的动态代理：
         *      涉及的类：Enhancer
         *      提供者：第三方cglib库
         *  如何创建代理对象：
         *      使用Enhancer类中的create方法
         *  创建代理对象的要求：
         *      被代理类不能是最终类
         *  create方法的参数：
         *      Class：字节码
         *          它是用于指定被代理对象的字节码。
         *
         *      Callback：用于提供增强的代码
         *          它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。
         *          此接口的实现类都是谁用谁写。
         *          我们一般写的都是该接口的子接口实现类：MethodInterceptor
         */
        Producer cglibProducer = (Producer) Enhancer.create(producer.getClass(), new MethodInterceptor() {
            /**
             * @function 执行被代理对象的任何接口方法都会经过该方法
             * @param proxy 代理对象的引用
             * @param method 当前执行的方法
             * @param args 参数
             * @param methodProxy ：当前执行方法的代理对象
             * @return returnValue 和被代理对象方法有相同的返回值
             * @throws Throwable
             */
            @Override
            public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
                Object returnValue = null;

                //1.获取方法执行的参数
                Float money = (Float)args[0];
                //2.判断当前方法是不是销售
                if("saleProduct".equals(method.getName())){
                    returnValue = method.invoke(producer,money*0.8f);
                }
                return returnValue;
            }
        });
        cglibProducer.saleProduct(12000f);
    }

}

```
</details>

## 第一章节的解决方案
创建账户业务层实现类的代理对象

<details>
  <summary>BeanFactory.java</summary>
  
```java
package com.itheima.factory;

import com.itheima.service.IAccountService;
import com.itheima.utils.TransactionManager;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * 用于创建Service的代理对象的工厂
 */
@Component("beanFactory")
public class BeanFactory {

    @Autowired
    private IAccountService accountService;

    @Autowired
    private TransactionManager txManager;

    public void setTxManager(TransactionManager txManager) {
        this.txManager = txManager;
    }


    public final void setAccountService(IAccountService accountService) {
        this.accountService = accountService;
    }

    /**
     * 获取Service代理对象
     * @return
     */
    public IAccountService getAccountService() {
        return (IAccountService)Proxy.newProxyInstance(accountService.getClass().getClassLoader(),
                accountService.getClass().getInterfaces(),
                new InvocationHandler() {
                    /**
                     * 添加事务的支持
                     *
                     * @param proxy
                     * @param method
                     * @param args
                     * @return
                     * @throws Throwable
                     */
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

                        if("test".equals(method.getName())){
                            return method.invoke(accountService,args);
                        }

                        Object rtValue = null;
                        try {
                            //1.开启事务
                            txManager.beginTransaction();
                            //2.执行操作
                            rtValue = method.invoke(accountService, args);
                            //3.提交事务
                            txManager.commit();
                            //4.返回结果
                            return rtValue;
                        } catch (Exception e) {
                            //5.回滚操作
                            txManager.rollback();
                            throw new RuntimeException(e);
                        } finally {
                            //6.释放连接
                            txManager.release();
                        }
                    }
                });

    }
}

```
</details>

当我们改造完成之后，业务层用于控制事务的重复代码就都可以删掉了。


# Spring中的AOP
## Spring中AOP的细节
### SOP术语
* Joinpoint(连接点): 所谓连接点是指那些被拦截到的点。  
在spring中,这些点指的是方法,因为spring只支持方法类型的连接点。 
* Pointcut(切入点): 所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。
* Advice(通知/增强): 所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。  
 通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。 
 * Introduction(引介): 引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field。 
 * Target(目标对象): 代理的目标对象。 
 * Weaving(织入): 是指把增强应用到目标对象来创建新的代理对象的过程。 spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。 
 * Proxy（代理）: 一个类被AOP织入增强后，就产生一个结果代理类。 Aspect(切面): 是切入点和通知（引介）的结合。

 ## 具体实现
 ### 创建spring的配置文件并导入约束
 1. 配置bean文件
 <details>
  <summary>bean.xml</summary>
  
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd">

    <!--配置代理的service-->
    <bean id="proxyAccountService" factory-bean="beanFactory" factory-method="getAccountService"></bean>

    <!--配置QueryRunner-->
    <bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"></bean>

    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <!--连接数据库的必备信息-->
        <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
        <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/learn"></property>
        <property name="user" value="root"></property>
        <property name="password" value="123456"></property>
    </bean>
    
    <context:component-scan base-package="com.itheima"/>
    <!-- 开启spring对注解AOP的支持 -->
    <aop:aspectj-autoproxy/>

</beans>
```
</details>

### 抽取公共代码制作成通知
<details>
  <summary>TransactionManager.java</summary>
  
```java
package com.itheima.utils;


import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.sql.SQLException;

/**
 * @author xiaolong_wu
 * @date 2019年09月27日
 * @function 和事务管理相关的工具类，它包含了，开启事务，提交事务，回滚事务和释放连接
 **/
@Component("txManager")
@Aspect  //表明当前类是一个切面类
public class TransactionManager {

    @Autowired
    private ConnectionUtils connectionUtils;

    public void setConnectionUtils(ConnectionUtils connectionUtils) {
        this.connectionUtils = connectionUtils;
    }

    /**
     * 开启事务
     */
    // 作用： 把当前方法看成是前置通知。
    // 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用。
    @Before("execution(* com.itheima.service.impl.*.*(..))")
    public void beginTransaction() {
        try {
            connectionUtils.getThreadConnection().setAutoCommit(false);
            System.out.println("### beginTransaction ###");
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * 提交事务
     */
    @AfterReturning("execution(* com.itheima.service.impl.*.*(..))")
    public void commit() {
        try {
            connectionUtils.getThreadConnection().commit();
            System.out.println("### commit ###");
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * 回滚事务
     */
    @AfterThrowing("execution(* com.itheima.service.impl.*.*(..))")
    @After("execution(* com.itheima.service.impl.*.*(..))")
    public void rollback() {
        try {
            System.out.println("### rollback ###");
            connectionUtils.getThreadConnection().rollback();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }


    /**
     * 释放连接
     */
    @After("execution(* com.itheima.service.impl.*.*(..))")
    public void release() {
        try {
            System.out.println("### release ###");
            connectionUtils.getThreadConnection().close();
            connectionUtils.removeConnection();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    // 作用： 指定切入点表达式
    @Pointcut("execution(* com.itheima.service.impl.*.*(..))")
    public void pt1() {
    }

    @Around("pt1()")//注意：千万别忘了写括号
    public Object transactionAround(ProceedingJoinPoint pjp) {
        //定义返回值
        Object rtValue = null;
        try {
            //获取方法执行所需的参数
            Object[] args = pjp.getArgs();
            //前置通知：开启事务
            beginTransaction();
            //执行方法
            rtValue = pjp.proceed(args);
            //后置通知：提交事务
            commit();
        } catch (Throwable e) {
            //异常通知：回滚事务
            rollback();
            e.printStackTrace();
        } finally {
            //最终通知：释放资源
            release();
        }
        return rtValue;
    }
}

```
</details>











# 3. 参考文档
[静态代理、JDK与CGLIB动态代理、AOP+IoC](https://www.cnblogs.com/best/p/5679656.html)  
[Spring中的AOP](../1.资料/Spring5第三天.pdf)









accountPro
目标：
1.注解编程
2.添加SpringAOP




