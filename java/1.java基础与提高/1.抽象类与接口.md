<!-- TOC -->

- [1. 抽象类和接口](#1-抽象类和接口)
    - [1.1. 概念](#11-概念)
        - [1.1.1. 抽象类](#111-抽象类)
        - [1.1.2. 接口](#112-接口)
    - [1.2. 案例](#12-案例)

<!-- /TOC -->

# 1. 抽象类和接口
[参考文档](https://www.cnblogs.com/xiaoxi/p/6599843.html)
## 1.1. 概念
### 1.1.1. 抽象类
在了解抽象类之前，先来了解一下抽象方法。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为：
```java
abstract void fun(); 
```
1. 含有抽象方法的类叫做抽象类。抽象类必须在类前用`abstract`关键字修饰。
2. 抽象类就是为了**继承**而存在的。
3. 包含抽象方法的类称为抽象类，`但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法`。
```java
[public] abstract class ClassName { 
    abstract void fun(); 
}
```

* 抽象类和普通类的区别：
    1. 抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。
    2. 抽象类不能用来创建对象；
    3. 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。
    
<div align="center"><a><img width="800" heigth="600" src="imgs/01.PNG"></a></div>
### 1.1.2. 接口
* 接口泛指供别人调用的方法或者函数。它是对行为的抽象。。
* 接口中可以含有变量和方法。**接口中的变量会被隐式地指定为public static final变量**（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，**接口中的方法必须都是抽象方法。**
* 从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。

## 1.2. 案例
1.抽象类

```java
abstract class Student
{
    abstract final void study();
    void sleep()
    {
        System.out.println("躺着");
    }
}

//子类
class GoodStudent extends Student
{
    void study(){
        System.out.println("Carefully study!!");
    }
}

```
2.接口
```java
interface Animal {
   public void eat();
   public void travel();
}

public class MammalInt implements Animal{
   public void eat(){
      System.out.println("Mammal eats");
   }
   public void travel(){
      System.out.println("Mammal travels");
   } 
   public int noOfLegs(){
      return 0;
   }
   public static void main(String args[]){
      MammalInt m = new MammalInt();
      m.eat();
      m.travel();
   }
}
```

区别:  

**1.语法层面**  
1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；  
2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是`public static final`类型的；  
3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
4）**一个类只能继承一个抽象类，而一个类却可以实现多个接口**。

**2.设计层面**  
1）`抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象`。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，**继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系**。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。  
2）**设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计**。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。

举个例子
```java
interface Alarm {
    void alarm();
}

abstract class Door {
    public abstract void open();
    public abstract void close();
}

class AlarmDoor extends Door implements Alarm{
    @Override
    public void alarm() {
    }
    @Override
    public void open() {
    }
    @Override
    public void close() {
    }
}
```



* 1）抽象类-->模板式设计;接口-->辐射式设计  
    * 抽象类如果添加新的方法，子类可以不用进行变更；（子类继承父类后，就拥有了父类的属性、方法）
        * PPT模板
    * 如果接口添加新的方法，则所有实现这个接口的类都必须进行相应的改动。
* 2）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。
    * 飞机、鸟都可以飞行，飞行是行为; 飞行Fly-->设计为接口。
    * 布谷鸟，大雁等都是鸟，鸟是事物；鸟 --> 设计抽象类Bird。