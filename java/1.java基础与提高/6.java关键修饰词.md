<!-- TOC -->

- [1. this修饰符](#1-this修饰符)
    - [1.1. this关键字用法案例](#11-this关键字用法案例)
    - [1.2. this关键字用法总结](#12-this关键字用法总结)
        - [1.2.1. 区分成员变量和全局变量](#121-区分成员变量和全局变量)
        - [1.2.2. 代表当前对象](#122-代表当前对象)
        - [1.2.3. 构造器与构造器之间的调用](#123-构造器与构造器之间的调用)
- [2. static修饰符](#2-static修饰符)
- [3. super关键字](#3-super关键字)
    - [3.1. 什么是super？什么是this？](#31-什么是super什么是this)
    - [3.2. 使用super&this调用成员变量和方法](#32-使用superthis调用成员变量和方法)
    - [3.3. ## 使用super&this调用构造子](#33--使用superthis调用构造子)
    - [3.4. 使用super&this应该注意些什么？](#34-使用superthis应该注意些什么)
    - [3.5. static用途](#35-static用途)
        - [3.5.1. static方法](#351-static方法)
        - [3.5.2. static变量](#352-static变量)
        - [3.5.3. static代码块](#353-static代码块)
    - [3.6. 静态导包](#36-静态导包)
    - [3.7. 总结](#37-总结)
        - [3.7.1. static用法](#371-static用法)
        - [3.7.2. 静态成员变量与非静态成员变量](#372-静态成员变量与非静态成员变量)
- [4. final修饰符](#4-final修饰符)
    - [4.1. 修饰类(class)。](#41-修饰类class)
    - [4.2. 修饰方法(method)](#42-修饰方法method)
    - [4.3. 修饰变量(variable)](#43-修饰变量variable)
    - [4.4. 修饰参数(arguments)](#44-修饰参数arguments)
    - [总结](#总结)
        - [修饰类](#修饰类)
        - [修饰方法](#修饰方法)
        - [修饰变量](#修饰变量)
    - [深入理解final关键字](#深入理解final关键字)
        - [类的final变量和普通变量有什么区别？](#类的final变量和普通变量有什么区别)
        - [被final修饰的引用变量指向的对象内容可变吗？](#被final修饰的引用变量指向的对象内容可变吗)
        - [final参数的问题](#final参数的问题)

<!-- /TOC -->

# 1. this修饰符
## 1.1. this关键字用法案例
this总的来说表示指向当前对象的指针。  
```java
public class ThisStart {
    private int i = 0;
    //构造函数1：
    public ThisStart(int i){
        int a = this.i; // 此时this表示引用成员变量ｉ，而非函数参数ｉ
        this.i ++;
        System.out.println("*** this.i :" + a);
        System.out.println("*** i:" + i);
        System.out.println("*** this.i++:" + this.i++); //this表示当前的对象
    }

    //构造函数2：
    public ThisStart(int i,int s){
        this(s);  //this调用第一个构造器，必须为于其第一行，构造方法也只能调用一个且仅一次构造器！
        System.out.println("### i:" + i);
        System.out.println("### s:" + s);
    }

    // 
    public ThisStart increment(){
        this.i++ ;
        return this;//返回的是当前的对象
    }

    public static void main(String[] args) {
        ThisStart thisStart1 = new ThisStart(100);
        System.out.println("----------------- test1 -----------------");
        ThisStart thisStart2 = new ThisStart(30,50);
        System.out.println("----------------- test2 -----------------");
        System.out.println( thisStart1.increment());
    }
}
```
【程序执行结果】
```
*** this.i :0
*** i:100
*** this.i:com.base.modifierstart.ThisStart@3af49f1c
----------------- test1 -----------------
*** this.i :0
*** i:50
*** this.i:com.base.modifierstart.ThisStart@19469ea2
### i:30
### s:50
----------------- test2 -----------------
com.base.modifierstart.ThisStart@3af49f1c
```
【说明】
* 构造函数1中：this表示引用成员变量ｉ，而非函数参数ｉ。
* 构造函数2中：this调用第一个构造器，必须为于其第一行，构造方法也只能调用一个且仅一次构造器。
* increment()方法中，返回的是当前的对象。

## 1.2. this关键字用法总结
### 1.2.1. 区分成员变量和全局变量
```java
public class ThisDemo {
    public static void main(String[] args) {
        Student s=new Student("小明明",20);
        System.out.println(s);
    }
}
class Student{
    String name;
    int age;
    public Student(String name, int age) {
        //注:没有加this
        name = name;
        age = age;
    }
    @Override
    public String toString() {
        return "Student [ name=" + name + ", age=" + age +"]";
    }
}
```
【运行结果1】
```
Student [ name=null, age=0]
```
如果将构造函数修改
```java
public Student(String name, int age) {
        //注:没有加this
        this.name = name;
        this.age = age;
    }
```
【运行结果2】
```
Student [ name=小明明, age=20]
```
### 1.2.2. 代表当前对象
```java
public static void main(String[] args) {
            Student s=new Student("小明明",20);
            System.out.println(s);
    }
    //为什么加入this后就可以区分呢？
    因为this当前代表的是s实例(对象)相当于
    s.name="小明明";
    s.age="20";
    //再可以理解如下
    this.name=实例(对象).name="小明明";
```
### 1.2.3. 构造器与构造器之间的调用
1.1小节中的this(s)就是调用构造器。
这里介绍另外一个例子
```java
class StudentPlus{
    String name;
    int age;
    int id;
    public StudentPlus(String name, int age, int id) {
        this.name = name;
        this.age = age;
        this.id = id;
        System.out.println("构造器3已调用");
    }
    public StudentPlus(String name, int age) {
        this(name,age,0);//通过this调用构造函数
        System.out.println("构造器2已调用");
    }

    public StudentPlus(String name) {
        this(name,0);//参数不足,就使用参数默认值补全
        System.out.println("构造器1已调用");
    }
    @Override
    public String toString() {
        return "Student [ id=" + id + ", name=" + name + ", age=" + age +"]";
    }

    public static void main(String[] args) {
        StudentPlus s=new StudentPlus("小明明");//通过this调用构造函数
        System.out.println(s);
    }
}
```
【运行结果】
```
构造器3已调用
构造器2已调用
构造器1已调用
Student [ id=0, name=小明明, age=0]
```

# 2. static修饰符
&emsp;&emsp;static不能和this同时使用，因为static是供类所有，是所有对象共享的，类似全局变量。首次加载类的时候就分配了内存，并且被static修饰的方法和变量JVM只加载一次。  
&emsp;&emsp;被static修饰的变量称为`类变量`，被static修饰的方法称为`类方法`或者`静态方法`；没被修饰的称为实例变量，实例方法。

在《Java编程思想》P86页有这样一段话：  
&emsp;&emsp;`static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。`  
【概括】方便在没有创建对象的情况下来进行调用（方法/变量）。  
很显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。  
static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。

# 3. super关键字
子类不能继承父类的构造方法，更不能覆盖父类的构造方法。因此，子类如果想使用父类的构造方法，必须在子类的构造方法中使用，而且必须使用关键字super来表示，而且super必须是子类构造方法中的头一条语句。

如果子类的属性名和父类重名，默认是子类的属性。调用父类的同名属性需要super.属性名；

## 3.1. 什么是super？什么是this？
super关键字表示超（父）类的意思。this变量代表对象本身。

## 3.2. 使用super&this调用成员变量和方法
可以使用super访问父类被子类隐藏的变量或覆盖的方法。当前类如果是从超类继承而来的，当调用super.XX()就是调用基类版本的XX（）方法。见示例1。  
当类中有两个同名变量，一个属于类（类的成员变量），而另一个属于某个特定的方法（方法中的局部变量），使用this区分成员变量和局部变量。见示例2。

```java
//示例1：
public class NewPerson {
    protected void myPprint() {
        System.out.println("The print() in class Person.");
    }
}

public class DemoSuper extends NewPerson {
    public void print() {
        System.out.println("The print() in class DemoSuper.");
        super.myPprint();// 调用父类的方法
    }

    public static void main(String[] args) {
        DemoSuper ds = new DemoSuper();
        ds.print();
    }
}
```
【运行结果】
```
The print() in class DemoSuper.
The print() in class Person.
```

```java
//示例2：
public class DemoThis {
    private String name;
 
    public void setName(String name) {
       this.name = name;// 前一个name是private name；后一个name是setName中的参数。
    }
}
```

## 3.3. ## 使用super&this调用构造子
```java
public class MyPerson {
    public static void ptr(String s) {
        System.out.println(s);
    }

    MyPerson() {
        ptr("A Person");
    }

    MyPerson(String name) {
        ptr("A person's name is:" + name);
    }
}

public class Chinese extends MyPerson {
    Chinese() {
        super();// 调用父类构造函数。
        ptr("A chinese.");
    }

    Chinese(String name) {
        super(name);// 调用父类具有相同形参的构造函数。
        ptr("his name is:" + name);
    }

    public static void main(String[] args) {
        Chinese cn = new Chinese();
        cn = new Chinese("kevin");
    }
}
```

## 3.4. 使用super&this应该注意些什么？
1）调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。  
 
2）super()和this()类似,区别是，super从子类中调用父类的构造方法，this()在同一类内调用其它方法。  
 
3）super()和this()均需放在构造方法内第一行。  
 
4）尽管可以用this调用一个构造器，但却不能调用两个。  
 
5）this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。  
 
6）this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。  
 
7）从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。  






## 3.5. static用途
### 3.5.1. static方法
* 非静态成员方法可以调用
* 禁止在静态成员方法中访问非静态成员方法。
* 因此，如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。我们最常见的static方法就是main方法，程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。

```java
public class StaticStart {
    private static String str1 = "staticProperty";
    private String str2 = "normalProperty";

    public void print1(){
        System.out.println(str1);
        System.out.println(str2);
        print2();
    }
    //静态成员方方法
    public static void print2(){
        System.out.println(str1);
        System.out.println(str2);//报错
        print1();//报错
    }
}
```
### 3.5.2. static变量
* static变量也称作`静态变量`，静态变量和非静态变量的区别是：**静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响**。

　　static成员变量的初始化顺序按照定义的顺序进行初始化。

### 3.5.3. static代码块
static关键字还有一个比较关键的作用就是：**用来形成静态代码块以优化程序性能**。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。

　　为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。下面看个例子:
```java
class Person{
    private int  age;
    public Person(int age) {
        this.age = age;
    }
    boolean isBornBoomer(int age) {
        int smallAge = 25;
        int largeAge = 50;
        return age > smallAge && age < largeAge;
    }
}
```
isBornBoomer用于判断年龄是否在25岁到50岁之间。每次该方法被调用，都要生成smallAge 和 largeAge两个变量，造成空间浪费，这样效果会更好。
```java
class Person{
    private int  age;
    private static int smallAge,largeAge;
    static {
        int smallAge = 25;
        int largeAge = 50;
    }
    public Person(int age) {
        this.age = age;
    }
    boolean isBornBoomer(int age) {
        return age > smallAge && age < largeAge;
    }
}
```

## 3.6. 静态导包

```java
/* PrintHelper.java文件 */
package com.dotgua.study;

public class PrintHelper {

    public static void print(Object o){
        System.out.println(o);
    }
}

/* App.java文件 */

import static com.dotgua.study.PrintHelper.*;

public class App 
{
    public static void main( String[] args )
    {
        print("Hello World!");
    }
    /**Output
     * Hello World!
     *///~
}
```
而在App.java文件中，我们首先将PrintHelper类导入，这里在导入时，我们使用了static关键字，而且在引入类的最后还加上了“.*”，它的作用就是将PrintHelper类中的所有类方法直接导入。不同于非static导入，采用static导入包后，在不与当前类的方法名冲突的情况下，无需使用“类名.方法名”的方法去调用类方法了，直接可以采用"方法名"去调用类方法，就好像是该类自己的方法一样使用即可。

## 3.7. 总结
### 3.7.1. static用法  
static是java中非常重要的一个关键字，而且它的用法也很丰富，主要有四种用法：  
* 用来修饰成员变量，将其变为类的成员，从而实现所有对象对于该成员的共享；
* 用来修饰成员方法，将其变为类方法，可以直接使用“类名.方法名”的方式调用，常用于工具类；
* 静态块用法，将多个类成员放在一起初始化，使得程序更加规整，其中理解对象的初始化过程非常关键；
* 静态导包用法，将类的方法直接导入到当前类中，从而直接使用“方法名”即可调用类方法，更加方便。
### 3.7.2. 静态成员变量与非静态成员变量
静态的成员变量与非静态的成员变量的区别：
1. 作用上的区别：
1. 静态的成员变量的作用共享一个 数据给所有的对象使用。
2. 非 静态的成员变量的作用是描述一类事物的公共属性。
2. 数量与存储位置上的区别：
1. 静态成员变量是存储方法 区内存中，而且只会存在一份数据。
2. 非静态的成员变量是存储在堆内存中，有n个对象就有n份数据。
3. 生命周期的区别：
1. 静态的成员变量数据是随着类的加载而存在，随着类文件的消失而消失。
2.非静态的成员数据是随着对象的创建而存在，随着 对象被垃圾回收器回收而消失。

# 4. final修饰符
## 4.1. 修饰类(class)。 
* 1、该类不能被继承。 
* 2、类中的方法不会被覆盖，因此默认都是final的。 
* 3、用途：设计类时，如果该类不需要有子类，不必要被扩展，类的实现细节不允许被改变，那么就设计成final类
## 4.2. 修饰方法(method) 
* 1、该方法可以被继承，但是不能被覆盖。 
* 2、用途：一个类不允许子类覆盖该方法，则用final来修饰 
* 3、好处：可以防止继承它的子类修改该方法的意义和实现；更为高效，编译器在遇到调用fianal方法转入内嵌机制，提高了执行效率。 
* 4、注意：父类中的private成员方法不能被子类覆盖，因此，private方法默认是final型的(可以查看编译后的class文件)
## 4.3. 修饰变量(variable) 
* 1、用final修饰后变为常量。包括静态变量、实例变量和局部变量这三种。 
* 2、特点：可以先声明，不给初值，这种叫做final空白。但是使用前必须被初始化。一旦被赋值，将不能再被改变。
## 4.4. 修饰参数(arguments) 
* 1、用final修饰参数时，可以读取该参数，但是不能对其作出修改。

## 总结
### 修饰类
当用final修饰一个类时，表明`这个类不能被继承`。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。`final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。`

在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。

### 修饰方法
目的：把方法锁定，以防任何继承类修改它的含义  
 final修饰的方法表示此方法已经是“最后的、最终的”含义，亦即此方法不能被重写。也就是说子类是不能够存在和父类一模一样的方法的。
【注意】
如果父类中final修饰的方法同时访问控制权限为`private`，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义相同的方法名和参数.

### 修饰变量
final成员变量表示常量，只能被赋值一次，赋值后值不再改变。

## 深入理解final关键字
### 类的final变量和普通变量有什么区别？

```java
@Test
    public void test13(){
        String a = "hello2";
        final String b = "hello";
        String d = "hello";
        String c = b + 2;
        String e = d + 2;
        System.out.println((a == c));//true
        System.out.println((a == e));//false
    }
```

【说明】  
当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译期常量使用。也就是说在用到该final变量的地方，相当于直接访问的这个常量，不需要在运行时确定。

【注意】
不过要注意，只有在编译期间能确切知道final变量值的情况下，编译器才会进行这样的优化，比如下面的这段代码就不会进行优化：
```java
@Test
    public void test14(){
        String a = "hello2";
        final String b = getHello(); //结果需要在运行时才能知道
        String c = b + 2;
        System.out.println((a == c));//false
    }

    public static String getHello() {
        return "hello";
    }
```

### 被final修饰的引用变量指向的对象内容可变吗？
```java
 @Test
    public void test15(){
        final MyClass myClass = new MyClass();
        System.out.println(++myClass.i);
    }

    class MyClass {
        public int i = 0;
    }
```

输出结果为1。`这说明引用变量被final修饰之后，虽然不能再指向其他对象，但是它指向的对象的内容是可变的`。

### final参数的问题
```java
public void changeValue(final int i){
        //final参数不可改变
        //i++; //会报错
        System.out.println(i);
    }
```

该参数是不可改变的。


























* 【参考文档】  
[1.java this 3种常见用法 详解](https://blog.csdn.net/u012176204/article/details/54580232)  
[2.java中非常重要的修饰词---static、this、final、super](https://blog.csdn.net/chenluvshero/article/details/52515627)
[3.java super和this总结](https://pig66.blog.csdn.net/article/details/48395891)
